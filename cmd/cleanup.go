package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/ironicbadger/jankey/internal/apikey"
	"github.com/ironicbadger/jankey/internal/config"
	"github.com/ironicbadger/jankey/internal/oauth"
	"github.com/ironicbadger/jankey/internal/pass"
	"github.com/ironicbadger/jankey/internal/tailscale"
	"github.com/ironicbadger/jankey/pkg/models"
)

var (
	cleanupDryRun bool
	cleanupAll    bool
)

var cleanupCmd = &cobra.Command{
	Use:   "cleanup",
	Short: "Manage auth keys created by jankey",
	Long: `List and clean up auth keys that were created by jankey.

Auth keys created by jankey have "Generated by jankey" in their description.
This command helps you manage and remove old or unused keys.`,
	RunE: runCleanup,
}

func init() {
	rootCmd.AddCommand(cleanupCmd)

	cleanupCmd.Flags().BoolVar(&cleanupDryRun, "dry-run", false, "list keys that would be deleted without actually deleting them")
	cleanupCmd.Flags().BoolVar(&cleanupAll, "all", false, "delete all jankey-created auth keys (use with caution)")
}

func runCleanup(cmd *cobra.Command, args []string) error {
	// Get config path
	configPath := cfgFile
	if configPath == "" {
		var err error
		configPath, err = config.GetConfigPath()
		if err != nil {
			return fmt.Errorf("failed to get config path: %w", err)
		}
	}

	// Load configuration
	cfg, err := config.LoadOrDefault(configPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Initialize pass client
	var passClient *pass.Client
	if pass.IsInstalled() {
		passClient, err = pass.New()
		if err != nil && verbose {
			fmt.Fprintf(os.Stderr, "Warning: %v\n", err)
		}
	}

	// Determine auth method and get credentials
	if useOAuth {
		return cleanupWithOAuth(cfg, passClient)
	}

	return cleanupWithAPIKey(cfg, passClient)
}

func cleanupWithAPIKey(cfg *models.Config, passClient *pass.Client) error {
	// Get API key
	apiKeyValue, err := pass.GetFromPassOrEnv(passClient, cfg.APIKey.PassPathAPIKey, "TS_API_KEY")
	if err != nil {
		return fmt.Errorf("failed to get API key: %w\n\nRun with --init to configure credentials or set TS_API_KEY environment variable", err)
	}

	// Create API key client
	apiClient := apikey.New(apiKeyValue, verbose)

	// Validate API key
	if err := apiClient.ValidateAPIKey(); err != nil {
		return fmt.Errorf("API key validation failed: %w", err)
	}

	// List auth keys
	keys, err := apiClient.ListAuthKeys()
	if err != nil {
		return fmt.Errorf("failed to list auth keys: %w", err)
	}

	// Filter for jankey-created keys
	jankeyKeys := filterJankeyKeysGeneric(keys)

	if len(jankeyKeys) == 0 {
		fmt.Println("No auth keys created by jankey found.")
		return nil
	}

	// Display found keys
	fmt.Printf("Found %d auth key(s) created by jankey:\n\n", len(jankeyKeys))
	displayAuthKeysGeneric(jankeyKeys)

	// Handle deletion
	if cleanupAll {
		if cleanupDryRun {
			fmt.Printf("\n[DRY RUN] Would delete %d auth key(s)\n", len(jankeyKeys))
			return nil
		}

		fmt.Printf("\nDeleting %d auth key(s)...\n", len(jankeyKeys))
		return deleteAuthKeys(apiClient, jankeyKeys)
	}

	fmt.Println("\nUse --all to delete these keys, or --dry-run to preview deletion.")
	return nil
}

func cleanupWithOAuth(cfg *models.Config, passClient *pass.Client) error {
	// Get OAuth credentials
	clientID, err := pass.GetFromPassOrEnv(passClient, cfg.OAuth.PassPathClientID, "TS_OAUTH_CLIENT_ID")
	if err != nil {
		return fmt.Errorf("failed to get OAuth client ID: %w\n\nRun with --init to configure credentials", err)
	}

	clientSecret, err := pass.GetFromPassOrEnv(passClient, cfg.OAuth.PassPathClientSecret, "TS_OAUTH_CLIENT_SECRET")
	if err != nil {
		return fmt.Errorf("failed to get OAuth client secret: %w\n\nRun with --init to configure credentials", err)
	}

	// Get OAuth access token
	oauthClient := oauth.New(clientID, clientSecret, verbose)
	accessToken, err := oauthClient.GetAccessToken()
	if err != nil {
		return fmt.Errorf("failed to get OAuth access token: %w", err)
	}

	// Create Tailscale client
	tsClient := tailscale.New(accessToken, verbose)

	// List auth keys
	keys, err := tsClient.ListAuthKeys()
	if err != nil {
		return fmt.Errorf("failed to list auth keys: %w", err)
	}

	// Filter for jankey-created keys
	jankeyKeys := filterJankeyKeysGeneric(keys)

	if len(jankeyKeys) == 0 {
		fmt.Println("No auth keys created by jankey found.")
		return nil
	}

	// Display found keys
	fmt.Printf("Found %d auth key(s) created by jankey:\n\n", len(jankeyKeys))
	displayAuthKeysGeneric(jankeyKeys)

	// Handle deletion
	if cleanupAll {
		if cleanupDryRun {
			fmt.Printf("\n[DRY RUN] Would delete %d auth key(s)\n", len(jankeyKeys))
			return nil
		}

		fmt.Printf("\nDeleting %d auth key(s)...\n", len(jankeyKeys))
		return deleteAuthKeys(tsClient, jankeyKeys)
	}

	fmt.Println("\nUse --all to delete these keys, or --dry-run to preview deletion.")
	return nil
}

func containsJankeySignature(description string) bool {
	// Check for our signature in the description
	return contains(description, "Generated by jankey") ||
	       contains(description, "🤖 Generated with [Claude Code]")
}

func displayAuthKeysGeneric(keys []AuthKeyInfo) {
	for i, key := range keys {
		fmt.Printf("%d. ID: %s\n", i+1, key.GetID())
		fmt.Printf("   Created: %s\n", key.GetCreated())
		fmt.Printf("   Expires: %s\n", key.GetExpires())

		if key.GetDescription() != "" {
			fmt.Printf("   Description: %s\n", key.GetDescription())
		}

		fmt.Println()
	}
}

type AuthKeyInfo interface {
	GetID() string
	GetCreated() string
	GetExpires() string
	GetDescription() string
}

type AuthKeyDeleter interface {
	DeleteAuthKey(keyID string) error
}

func filterJankeyKeysGeneric(keys interface{}) []AuthKeyInfo {
	var jankeyKeys []AuthKeyInfo

	// Handle both apikey.AuthKey and tailscale.AuthKey
	switch k := keys.(type) {
	case []apikey.AuthKey:
		for _, key := range k {
			if containsJankeySignature(key.Description) {
				jankeyKeys = append(jankeyKeys, authKeyWrapper{
					id:          key.ID,
					created:     key.Created.Format("2006-01-02 15:04:05"),
					expires:     key.Expires.Format("2006-01-02 15:04:05"),
					description: key.Description,
				})
			}
		}
	case []tailscale.AuthKey:
		for _, key := range k {
			if containsJankeySignature(key.Description) {
				jankeyKeys = append(jankeyKeys, authKeyWrapper{
					id:          key.ID,
					created:     key.Created.Format("2006-01-02 15:04:05"),
					expires:     key.Expires.Format("2006-01-02 15:04:05"),
					description: key.Description,
				})
			}
		}
	}

	return jankeyKeys
}

type authKeyWrapper struct {
	id          string
	created     string
	expires     string
	description string
}

func (a authKeyWrapper) GetID() string          { return a.id }
func (a authKeyWrapper) GetCreated() string     { return a.created }
func (a authKeyWrapper) GetExpires() string     { return a.expires }
func (a authKeyWrapper) GetDescription() string { return a.description }

func deleteAuthKeys(client AuthKeyDeleter, keys []AuthKeyInfo) error {
	deletedCount := 0
	errorCount := 0

	for _, key := range keys {
		if err := client.DeleteAuthKey(key.GetID()); err != nil {
			fmt.Fprintf(os.Stderr, "❌ Failed to delete key %s: %v\n", key.GetID(), err)
			errorCount++
		} else {
			fmt.Printf("✓ Deleted key %s\n", key.GetID())
			deletedCount++
		}
	}

	fmt.Printf("\nDeleted %d key(s)", deletedCount)
	if errorCount > 0 {
		fmt.Printf(", %d error(s)", errorCount)
	}
	fmt.Println()

	if errorCount > 0 {
		return fmt.Errorf("failed to delete %d key(s)", errorCount)
	}

	return nil
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && (s[:len(substr)] == substr || contains(s[1:], substr))))
}
